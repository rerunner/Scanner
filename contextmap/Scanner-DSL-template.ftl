#pragma once
// Auto-generated by user ${userName} at ${timestamp} from the Context Map '${contextMap.name}' stored in ${filename}
// using contextMapper version <#if contextMapperVersion?has_content>${contextMapperVersion}<#else>unknown</#if>

#include <list>
#include <memory>
#include <nlohmann/json.hpp>
#include <cppkafka/cppkafka.h>
#include "hiberlite.h"
#include "domain/base/AggregateRootBase.hpp"
#include "domain/base/ValueObjectBase.hpp"
#include "infrastructure/base/IRepositoryFactory.h"
#include "infrastructure/base/IRepositoryBase.h"
#include "infrastructure/base/RepositoryFactory.h"
#include "FiniteStateMachine.hpp"
#include "GenLogger.hpp"

#define boolean bool /* for now */

<#import "domain-object-attribute-and-operation-tables.ftl" as attrOpsMacro>

<#assign allEntityNames = [] />
<#assign allValueobjectNames = [] />
<#assign oneToManyRefs = [] />
<#assign oneToOneRefs = [] />
<#assign allJsonBoilerPlate = [] />

<#list contextMap.boundedContexts as bc>
<#list bc.aggregates as agg>
<#assign entities = [] />
<#assign entityNames = [] />
<#assign valueobjects = [] />
<#assign valueobjectNames = [] />
<#assign enums = [] />
<#assign enumNames = [] />
<#assign jsonBoilerPlate = [] />
<#assign entities = entities + agg.domainObjects?filter(dob -> instanceOf(dob, Entity))>
<#assign valueobjects = valueobjects + agg.domainObjects?filter(dob -> instanceOf(dob, ValueObject))>
<#assign enums = enums + agg.domainObjects?filter(dob -> instanceOf(dob, Enum))>
<#if entities?has_content>
// Bounded Context ${bc.name} '${bc.domainVisionStatement}'<#lt>
// is of type ${bc.type}
// and is responsible for ${bc.responsibilities?join(", ")}
namespace ${bc.name} {
    using namespace Verdi;
    using json = nlohmann::json;
    using namespace std;

<#-- Enum class and StateMachine code generation -->
<#if enums?has_content>
<#list enums as enum>
<#if enum.isDefinesAggregateLifecycle()>
    // found aggregate lifecycle enum ${enum.name}
    namespace ${agg.name?lower_case}State {
    <#list enum.getValues() as enumVal>
        struct ${enumVal.name};
    </#list>

        // specific supported state transition types
    <#list enum.getValues() as enumVal>
        struct transition_to_${enumVal.name}{};
    </#list>
        #include "domain/${agg.name}StateTransitions.cpp" // include manual written statetransition rules
    } // namespace ${agg.name?lower_case}State

    using ${agg.name?lower_case}_state_machine = GSL::state_machine<
<#list enum.getValues() as enumVal>
                                ${agg.name?lower_case}State::${enumVal.name}<#if enumVal?has_next>,<#else>>;</#if>
</#list> 
<#else>

    // found non-aggregate lifecycle enum ${enum.name}
    enum  ${enum.name}
    {
    <#list enum.getValues() as enumVal>
        ${enumVal.name}<#if enumVal?has_next>,<#else></#if>
    </#list> 
    };
</#if>
</#list>
</#if>
<#-- ValueObject class code generation -->
<#assign valueobjectNames = valueobjects?map(e -> e.name)>
<#assign allValueobjectNames = allValueobjectNames + valueobjectNames>
<#if valueobjects?has_content>
<#list valueobjects as valueobject>
    <#if valueobject.name == "Uuid">
    // Uuid class is not generated, instead included from Verdi
    <#else>
    class ${valueobject.name} : public Verdi::ValueObjectBase 
    {
    private:
        <#assign allJsonBoilerPlate = [] />
        <#assign jsonBoilerPlate = [] />
        <#assign jsonAttributesBoilerPlate = [] />
        // attributes
        <#list valueobject.attributes as attribute>
        ${attribute.type} ${attribute.name};
        <#assign jsonAttributesBoilerPlate = valueobject.attributes?map(e -> e.name)>
        </#list>
        // references
        <#list valueobject.references as reference>
        <#if reference.collectionType?has_content && reference.collectionType.name() == "LIST">
        std::list<${reference.domainObjectType.name}> ${reference.name}; // ${reference.collectionType.name()}
        <#assign jsonBoilerPlate = valueobject.references?map(e -> e.name)>
        <#else>
        std::shared_ptr<${reference.domainObjectType.name}> ${reference.name}; // ${reference.collectionType.name()}
        <#assign jsonBoilerPlate = valueobject.references?map(e -> e.name)>
        </#if>
        <#assign allJsonBoilerPlate = jsonBoilerPlate>
        </#list>
        // Hiberlite boilerplate start
        friend class hiberlite::access;
        template < class Archive >
        void hibernate(Archive & ar)
        {   
            <#if jsonAttributesBoilerPlate?has_content>
            <#list jsonAttributesBoilerPlate as jabp>
	        ar & HIBERLITE_NVP(${jabp}); // attribute
            </#list>
            </#if>
            <#if jsonBoilerPlate?has_content>
            <#list jsonBoilerPlate as jbp>
	        ar & HIBERLITE_NVP(${jbp}); // reference
            </#list>
            </#if>
        }
        // Hiberlite boilerplate end
    public:
        ${valueobject.name}(){}
        <#-- Call method declaration generator -->
        <@attrOpsMacro.renderDomainObjectOperationsAndAttributes valueobject />
        virtual ~${valueobject.name}(){}
        bool operator==(const ValueObjectBase& other) const override;
        // RavenDB & FFS boilerplate start
        NLOHMANN_DEFINE_TYPE_INTRUSIVE(${valueobject.name}<#list valueobject.attributes as attribute>,${attribute.name}</#list><#if jsonBoilerPlate?has_content><#list jsonBoilerPlate as jbp>,${jbp}</#list></#if>)
        // RavenDB & FFS boilerplate end
    };
    </#if>
</#list> 
</#if>
<#-- Entity class code generation -->
<#list entities as entity>
    
    <#if entity.aggregateRoot>
    class ${entity.name} : public std::enable_shared_from_this<${entity.name}> , public Verdi::AggregateRootBase
    {
    private:
        <#if enums?has_content>
        <#list enums as enum>
        <#if enum.isDefinesAggregateLifecycle()>
        // Aggregate lifecycle state part
        ${agg.name?lower_case}_state_machine ${agg.name?lower_case}StateMachine;
        std::string state; 
        // Kafka part
        std::shared_ptr<cppkafka::Producer> kafkaProducer;
        void stateChangePublisher()
        {   json jMessage;
            jMessage.emplace("Message", "StateChange");
            jMessage.emplace("Id", id_.Get());
            jMessage.emplace("State", state);
            // serialize to CBOR
            std::vector<std::uint8_t> message = json::to_cbor(jMessage);
            cppkafka::Buffer bmess(message); // Make sure the kafka message is using the cbor binary format and not a string
            kafkaProducer->produce(cppkafka::MessageBuilder("${agg.name?lower_case}StateTopic").partition(0).payload(bmess));
            try {kafkaProducer->flush();}
            catch (std::exception& e) 
            {   GSL::Dprintf(GSL::ERROR, "kafka flush failed with: ", e.what());
            }
        }
        </#if>
        </#list>
        </#if>
    <#else>
    class ${entity.name} : public Verdi::EntityBase 
    {
    private:
    </#if>
        <#assign allJsonBoilerPlate = [] />
        <#assign jsonBoilerPlate = [] />
        <#assign jsonAttributesBoilerPlate = [] />
        // attributes
        <#list entity.attributes as attribute>
        ${attribute.type} ${attribute.name};
        <#assign jsonAttributesBoilerPlate = entity.attributes?map(e -> e.name)>
        </#list>
        // references
        <#list entity.references as reference>
        <#if reference.collectionType?has_content && reference.collectionType.name() == "LIST">
        std::list<${reference.domainObjectType.name}> ${reference.name}; // ${reference.collectionType.name()}
        <#assign jsonBoilerPlate = entity.references?map(e -> e.name)>
        <#else>
        std::shared_ptr<${reference.domainObjectType.name}> ${reference.name}; // ${reference.collectionType.name()}
        </#if>
        <#assign allJsonBoilerPlate = jsonBoilerPlate>
        </#list>
        // Hiberlite boilerplate start
        friend class hiberlite::access;
        template < class Archive >
        void hibernate(Archive & ar)
        {   ar & HIBERLITE_NVP(id_); // From Base class
            ar & HIBERLITE_NVP(parentId_); // From Base class
            <#if jsonAttributesBoilerPlate?has_content>
            <#list jsonAttributesBoilerPlate as jabp>
            ar & HIBERLITE_NVP(${jabp}); // attribute
            </#list>
            </#if>
            <#if jsonBoilerPlate?has_content>
            <#list jsonBoilerPlate as jbp>
	        ar & HIBERLITE_NVP(${jbp}); // reference
            </#list>
            </#if>
        }
        // Hiberlite boilerplate end
    public:
        <#if entity.aggregateRoot>
        <#if enums?has_content>
        <#list enums as enum>
        <#if enum.isDefinesAggregateLifecycle()>
        <#assign enumVal = enum.getValues()>
        ${entity.name}()
        {   state = "${enumVal[0].name}"; // First declared state is initial state
            // Create the Kafka config
            std::unique_ptr<cppkafka::Configuration> kafkaConfig;
            GSL::Dprintf(GSL::DEBUG, "Creating the Kafka config");
            std::vector<cppkafka::ConfigurationOption> kafkaConfigOptions;
            cppkafka::ConfigurationOption ${agg.name?lower_case}ConfigOption{"metadata.broker.list", "localhost:9092"};
            kafkaConfigOptions.push_back(${agg.name?lower_case}ConfigOption);
            kafkaConfig = std::make_unique<cppkafka::Configuration>(cppkafka::Configuration{kafkaConfigOptions});
            // Create a Kafka producer instance
            GSL::Dprintf(GSL::DEBUG, "Creating a kafka producer instance");
            kafkaProducer = std::make_shared<cppkafka::Producer>(*kafkaConfig);
        }
        ${entity.name}(Uuid parentId)
        {   parentId_ = parentId; 
            <#list entity.references as reference>
            <#if reference.name == "parentLot_">
            parentLot_ = std::make_shared<Uuid>(parentId);
            </#if>
            </#list>
            state = "${enumVal[0].name}"; // First declared state is initial state
            // Create the Kafka config
            std::unique_ptr<cppkafka::Configuration> kafkaConfig;
            GSL::Dprintf(GSL::DEBUG, "Creating the Kafka config");
            std::vector<cppkafka::ConfigurationOption> kafkaConfigOptions;
            cppkafka::ConfigurationOption ${agg.name?lower_case}ConfigOption{"metadata.broker.list", "localhost:9092"};
            kafkaConfigOptions.push_back(${agg.name?lower_case}ConfigOption);
            kafkaConfig = std::make_unique<cppkafka::Configuration>(cppkafka::Configuration{kafkaConfigOptions});
            // Create a Kafka producer instance
            GSL::Dprintf(GSL::DEBUG, "Creating a kafka producer instance");
            kafkaProducer = std::make_shared<cppkafka::Producer>(*kafkaConfig);
        }
        ${entity.name}(std::shared_ptr<cppkafka::Producer> newkafkaProducer)
        {   state = "${enumVal[0].name}"; // First declared state is initial state
            kafkaProducer = newkafkaProducer;
        }
        ${entity.name}(Uuid parentId, std::shared_ptr<cppkafka::Producer> newkafkaProducer)
        {   parentId_ = parentId; 
            <#list entity.references as reference>
            <#if reference.name == "parentLot_">
            parentLot_ = std::make_shared<Uuid>(parentId);
            </#if>
            </#list>
            state = "${enumVal[0].name}"; // First declared state is initial state
            kafkaProducer = newkafkaProducer;
        }
        std::shared_ptr<${entity.name}> get${entity.name}() 
        {   return shared_from_this(); 
        }
        std::string GetCurrentState() const {return state;}
        </#if>
        </#list>
        <#list enums as enum>
        <#if enum.isDefinesAggregateLifecycle()>
        // Aggregate lifecycle state changes for ${enum.name}
        <#list enum.getValues() as enumVal>
        void ${enumVal.name}()
        {   ${agg.name?lower_case}StateMachine.on_state_transition(${agg.name?lower_case}State::transition_to_${enumVal.name}{});
            state = "${enumVal.name}";
            stateChangePublisher();
        }
        </#list> 
        </#if>
        </#list>
        <#else>
        <#-- Stateless Entity constructor class code generation -->
        ${entity.name}(){}
        ${entity.name}(Uuid parentId)
        {   parentId_ = parentId; 
            <#list entity.references as reference>
            <#if reference.name == "parentLot_">
            parentLot_ = std::make_shared<Uuid>(parentId);
            </#if>
            </#list>
        }
        </#if>
        </#if>
        Uuid Get${entity.name}Id(void){return id_;} // Id inherited from base class
        <@attrOpsMacro.renderDomainObjectOperationsAndAttributes entity />
        virtual ~${entity.name}(){}
        // RavenDB & FFS boilerplate start
        NLOHMANN_DEFINE_TYPE_INTRUSIVE(${entity.name}, id_, parentId_<#list entity.attributes as attribute>,${attribute.name}</#list><#if jsonBoilerPlate?has_content><#list jsonBoilerPlate as jbp>,${jbp}</#list></#if>)
        // RavenDB & FFS boilerplate end
    };
    <#-- Repository interface code generation -->
    <#if entity.repository?has_content>

    // Repository interface ${entity.repository.name} found for ${entity.name}
    class I${entity.repository.name} : public Verdi::IRepositoryBase<${entity.name}>
    {
    public:
        <@attrOpsMacro.renderDomainObjectOperationsAndAttributes entity.repository />
    };

    //
    // Infrastructure implementation of ${entity.name}Repository
    //
    class ${entity.repository.name} : public I${entity.repository.name}
    {
    private:
        RepositoryFactory<${entity.name}> ${entity.name?lower_case}RepoFactory;
        IRepositoryBase<${entity.name}> *repo;
    public:
        ${entity.repository.name}()
        {
            repo = ${entity.name?lower_case}RepoFactory.GetRepository(RepositoryTypeBase::REPOSITORY_TYPE);
        }
        void Store(${entity.name} ${entity.name?lower_case}) override 
        {
            repo->Store(${entity.name?lower_case});
        }
        void Delete(${entity.name} ${entity.name?lower_case}) override
        {
            repo->Delete(${entity.name?lower_case});
        }
        ${entity.name} Get(Uuid id) override
        {
            return repo->Get(id);
        }
        std::vector<${entity.name}> GetAll() override
        {
            return repo->GetAll();
        }
        std::vector<${entity.name}> GetAllChildren(Uuid id) override
        {
            return repo->GetAllChildren(id);
        }
    };
    </#if>
</#list> 
</#if>

} // namespace ${bc.name}

</#list> 
</#list>
<#assign entityNames = entities?map(e -> e.name)>
<#assign allEntityNames = allEntityNames + entityNames>
<#assign enumNames = enums?map(e -> e.name)>