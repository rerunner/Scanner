// Generated by the Context Map '${contextMap.name}'
#pragma once
#include <list>
#include "domain/base/AggregateRootBase.hpp"
#include "domain/base/ValueObjectBase.hpp"
#include "hiberlite.h"
#include <nlohmann/json.hpp>

<#import "domain-object-attribute-and-operation-tables.ftl" as attrOpsMacro>

<#assign allEntityNames = [] />
<#assign allValueobjectNames = [] />
<#assign oneToManyRefs = [] />
<#assign oneToOneRefs = [] />
<#assign allJsonBoilerPlate = [] />

<#list contextMap.boundedContexts as bc>
<#assign entities = [] />
<#assign entityNames = [] />
<#assign valueobjects = [] />
<#assign valueobjectNames = [] />
<#assign jsonBoilerPlate = [] />
<#list bc.aggregates as agg>
	<#assign entities = entities + agg.domainObjects?filter(dob -> instanceOf(dob, Entity))>
    <#assign valueobjects = valueobjects + agg.domainObjects?filter(dob -> instanceOf(dob, ValueObject))>
</#list>
<#assign entityNames = entities?map(e -> e.name)>
<#assign allEntityNames = allEntityNames + entityNames>

<#if entities?has_content>
/* Bounded Context ${bc.name} */<#lt>
namespace ${bc.name} {
<#list entities as entity>

    class ${entity.name} : public Verdi::AggregateRootBase 
    {
    private:
        <#list entity.attributes as attribute>
	    ${attribute.type} ${attribute.name};
        </#list>
        <#list entity.references as reference>
        <#if reference.collectionType?has_content && reference.collectionType.name() == "LIST">
        std::list<${reference.domainObjectType.name}> ${reference.name}; // ${reference.collectionType.name()}
        <#assign jsonBoilerPlate = entity.references?map(e -> e.name)>
        <#else>
        ${reference.domainObjectType.name} ${reference.name}; // ${reference.collectionType.name()}
        <#assign jsonBoilerPlate = entity.references?map(e -> e.name)>
        </#if>
        <#assign allJsonBoilerPlate = jsonBoilerPlate>
        </#list>
        <#if allJsonBoilerPlate?has_content>
        // Hiberlite boilerplate start
        friend class hiberlite::access;
        template < class Archive >
        void hibernate(Archive & ar)
        {
            ar & HIBERLITE_NVP(id_); // From Base class
            ar & HIBERLITE_NVP(parentId_); // From Base class
            <#list allJsonBoilerPlate as jbp>
	        ar & HIBERLITE_NVP(${jbp}_);
            </#list>
        }
        // Hiberlite boilerplate end
        </#if>
    public:
        <@attrOpsMacro.renderDomainObjectOperationsAndAttributes entity />
        
        // RavenDB & FFS boilerplate start
        <#if allJsonBoilerPlate?has_content>
        NLOHMANN_DEFINE_TYPE_INTRUSIVE(${entity.name}, ${allJsonBoilerPlate?join(", ")})
	    </#if>
        // RavenDB & FFS boilerplate end
    };

</#list> 
</#if>
<#assign valueobjectNames = valueobjects?map(e -> e.name)>
<#assign allValueobjectNames = allValueobjectNames + valueobjectNames>
<#if valueobjects?has_content>
<#list valueobjects as valueobject>

    class ${valueobject.name} : public Verdi::ValueObjectBase 
    {
    private:
        <#list valueobject.attributes as attribute>
	    ${attribute.type} ${attribute.name};
        </#list>
    public:
    };
</#list> 
</#if>

} // namespace ${bc.name}

</#list> 
